<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellogen Playground</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            background: #f5f5f5;
            color: #333333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: #e0e0e0;
            padding: 1rem 2rem;
            border-bottom: 1px solid #cccccc;
        }

        h1 {
            font-size: 1.5rem;
            color: #0066cc;
        }

        .subtitle {
            font-size: 0.85rem;
            color: #666666;
            margin-top: 0.25rem;
        }

        .controls a {
            color: #0066cc;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .controls a:hover {
            text-decoration: underline;
        }

        main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .panel-header {
            background: #e8e8e8;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            color: #555555;
            border-bottom: 1px solid #cccccc;
        }

        .editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
        }

        #line-numbers {
            position: relative;
            padding: 1rem 0.5rem 1rem 1rem;
            background: #f5f5f5;
            color: #999999;
            font-size: 14px;
            line-height: 1.5;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            text-align: right;
            user-select: none;
            border-right: 1px solid #e0e0e0;
            overflow: hidden;
            white-space: pre;
            min-width: 3em;
        }

        .editor-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #editor {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 1rem;
            background: transparent;
            color: transparent;
            caret-color: #333333;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            border: none;
            outline: none;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            overflow-y: auto;
            white-space: pre;
            overflow-wrap: normal;
            z-index: 2;
        }

        #highlight-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 1rem;
            background: #ffffff;
            color: #333333;
            font-size: 14px;
            line-height: 1.5;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
            overflow-y: auto;
            white-space: pre;
            overflow-wrap: normal;
            pointer-events: none;
            z-index: 1;
        }

        /* Syntax highlighting colors */
        .sg-comment { color: #7f8c8d; font-style: italic; }
        .sg-keyword { color: #9b59b6; font-weight: bold; }
        .sg-string { color: #27ae60; }
        .sg-number { color: #e67e22; }
        .sg-polarity { color: #e74c3c; font-weight: bold; }
        .sg-operator { color: #3498db; }
        .sg-variable { color: #2980b9; }
        .sg-function { color: #8e44ad; }

        #output {
            flex: 1;
            padding: 1rem;
            background: #ffffff;
            color: #333333;
            font-size: 14px;
            line-height: 1.5;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .controls {
            padding: 1rem 2rem;
            background: #e0e0e0;
            border-top: 1px solid #cccccc;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 0.5rem 1.5rem;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 2px;
            font-family: inherit;
        }

        button:hover {
            background: #0077dd;
        }

        button:active {
            background: #0055bb;
        }

        select {
            background: #ffffff;
            color: #333333;
            border: 1px solid #cccccc;
            padding: 0.5rem;
            font-size: 0.9rem;
            cursor: pointer;
            font-family: inherit;
            border-radius: 2px;
        }

        select:hover {
            background: #f0f0f0;
        }

        .divider {
            width: 1px;
            background: #cccccc;
        }

        .error {
            color: #d32f2f;
        }

        .success {
            color: #2e7d32;
        }

        #status {
            font-size: 0.85rem;
            color: #666666;
            margin-left: auto;
        }

        /* Mobile layout: stack vertically with output on top */
        @media (max-width: 768px) {
            main {
                flex-direction: column-reverse;
            }

            .divider {
                height: 1px;
                width: 100%;
                background: #cccccc;
            }

            .panel {
                min-height: 200px;
            }

            .controls {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            header {
                padding: 0.75rem 1rem;
            }

            h1 {
                font-size: 1.25rem;
            }

            .subtitle {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Stellogen Playground</h1>
        <div class="subtitle">Logic-agnostic programming based on term unification</div>
    </header>

    <main>
        <div class="panel">
            <div class="panel-header">Editor</div>
            <div class="editor-container">
                <div id="line-numbers" aria-hidden="true"></div>
                <div class="editor-wrapper">
                    <div id="highlight-layer" aria-hidden="true"></div>
                    <textarea id="editor" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off">'''
Terms
'''
X             ' variable (uppercase)
a             ' constant (lowercase & symbols)
$             ' another constant
(f X a)       ' function (constant) with terms as arguments
(+f X)        ' function with positive polarity
(-f X)        ' function with negative polarity
(-f (+f X) Y) ' nested functions
' Every Stellogen expression have these shapes (directly or indirectly)

'''
Term with effect: display terms
'''
(show hello)
(show hello world !)</textarea>
                </div>
            </div>
        </div>

        <div class="divider"></div>

        <div class="panel">
            <div class="panel-header">Output</div>
            <div id="output">Click "Run" to execute your code...</div>
        </div>
    </main>

    <div class="controls">
        <button id="runBtn">Run</button>
        <select id="examples">
            <option value="">Load Example...</option>
            <option value="hello">Hello</option>
            <option value="macros">Macros</option>
            <option value="prolog-arithmetic">Prolog - Arithmetic</option>
            <option value="prolog-family">Prolog - Family</option>
            <option value="states-nfa">NFA (Finite Automaton)</option>
            <option value="states-npda">NPDA (Pushdown Automaton)</option>
            <option value="states-turing">Turing Machine</option>
            <option value="proofnets-mall">Proof Nets - MALL</option>
            <option value="proofnets-mll">Proof Nets - MLL</option>
            <option value="proofnets-fomll">Proof Nets - FOMLL</option>
        </select>
        <button id="clearBtn">Clear</button>
        <button id="importBtn">üìÅ Import</button>
        <button id="exportBtn">üíæ Export</button>
        <input type="file" id="fileInput" accept=".sg,.stellogen,.txt" style="display: none;">
        <a href="https://github.com/engboris/stellogen/wiki/Basics-of-Stellogen" target="_blank" rel="noopener noreferrer">üìñ Tutorial</a>
        <span id="status"></span>
    </div>

    <script src="playground.js?v=__VERSION__"></script>
    <script src="examples.js?v=__VERSION__"></script>
    <script>
        const editor = document.getElementById('editor');
        const highlightLayer = document.getElementById('highlight-layer');
        const lineNumbers = document.getElementById('line-numbers');
        const output = document.getElementById('output');
        const runBtn = document.getElementById('runBtn');
        const clearBtn = document.getElementById('clearBtn');
        const importBtn = document.getElementById('importBtn');
        const exportBtn = document.getElementById('exportBtn');
        const fileInput = document.getElementById('fileInput');
        const examplesSelect = document.getElementById('examples');
        const status = document.getElementById('status');

        // Examples are now loaded from examples.js (auto-generated from examples/*.sg)

        // Syntax highlighting function
        function highlightSyntax(code) {
            // Escape HTML
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };

            // Use a token-based approach to avoid overlapping replacements
            const tokens = [];
            let pos = 0;

            // Keywords and operators
            const keywords = ['exec', 'fire', 'process', 'show', 'use', 'macro', 'spec', 'def'];

            // Tokenize the code
            while (pos < code.length) {
                let matched = false;

                // Comments (multi-line first)
                if (code.substr(pos, 3) === "'''") {
                    const end = code.indexOf("'''", pos + 3);
                    if (end !== -1) {
                        tokens.push({ type: 'comment', text: code.substring(pos, end + 3) });
                        pos = end + 3;
                        matched = true;
                    }
                }

                // Single-line comments
                if (!matched && code[pos] === "'" && (pos === 0 || code[pos-1] !== "'")) {
                    const end = code.indexOf('\n', pos);
                    const commentEnd = end === -1 ? code.length : end;
                    tokens.push({ type: 'comment', text: code.substring(pos, commentEnd) });
                    pos = commentEnd;
                    matched = true;
                }

                // Strings
                if (!matched && code[pos] === '"') {
                    const end = code.indexOf('"', pos + 1);
                    if (end !== -1) {
                        tokens.push({ type: 'string', text: code.substring(pos, end + 1) });
                        pos = end + 1;
                        matched = true;
                    }
                }

                // Polarity + function
                if (!matched && (code[pos] === '+' || code[pos] === '-')) {
                    const match = code.substring(pos).match(/^([+-])([a-z_][a-zA-Z0-9_]*)/);
                    if (match) {
                        tokens.push({ type: 'polarity', text: match[1] });
                        tokens.push({ type: 'function', text: match[2] });
                        pos += match[0].length;
                        matched = true;
                    }
                }

                // Operators
                const ops = [':=', '==', '~=', '||', '@', '#'];
                for (const op of ops) {
                    if (!matched && code.substr(pos, op.length) === op) {
                        tokens.push({ type: 'operator', text: op });
                        pos += op.length;
                        matched = true;
                        break;
                    }
                }

                // Keywords, variables, numbers, identifiers
                if (!matched && /[a-zA-Z0-9_]/.test(code[pos])) {
                    const match = code.substring(pos).match(/^[a-zA-Z0-9_]+/);
                    if (match) {
                        const word = match[0];
                        let type = 'text';
                        if (keywords.includes(word)) {
                            type = 'keyword';
                        } else if (/^[A-Z]/.test(word)) {
                            type = 'variable';
                        } else if (/^\d+$/.test(word)) {
                            type = 'number';
                        }
                        tokens.push({ type, text: word });
                        pos += word.length;
                        matched = true;
                    }
                }

                // Default: plain text
                if (!matched) {
                    tokens.push({ type: 'text', text: code[pos] });
                    pos++;
                }
            }

            // Generate HTML from tokens
            let html = '';
            for (const token of tokens) {
                const escaped = escapeHtml(token.text);
                switch (token.type) {
                    case 'comment': html += `<span class="sg-comment">${escaped}</span>`; break;
                    case 'keyword': html += `<span class="sg-keyword">${escaped}</span>`; break;
                    case 'string': html += `<span class="sg-string">${escaped}</span>`; break;
                    case 'number': html += `<span class="sg-number">${escaped}</span>`; break;
                    case 'polarity': html += `<span class="sg-polarity">${escaped}</span>`; break;
                    case 'operator': html += `<span class="sg-operator">${escaped}</span>`; break;
                    case 'variable': html += `<span class="sg-variable">${escaped}</span>`; break;
                    case 'function': html += `<span class="sg-function">${escaped}</span>`; break;
                    default: html += escaped;
                }
            }

            return html;
        }

        // Update line numbers
        function updateLineNumbers() {
            const text = editor.value;
            const lineCount = text.split('\n').length;
            let numbers = '';
            for (let i = 1; i <= lineCount; i++) {
                numbers += i + '\n';
            }
            lineNumbers.textContent = numbers;
        }

        // Update highlighting layer (no cursor manipulation needed!)
        function updateHighlighting() {
            const text = editor.value;
            highlightLayer.innerHTML = highlightSyntax(text);
            updateLineNumbers();
        }

        // Sync scroll between editor, highlight layer, and line numbers
        function syncScroll() {
            highlightLayer.scrollTop = editor.scrollTop;
            highlightLayer.scrollLeft = editor.scrollLeft;
            lineNumbers.scrollTop = editor.scrollTop;
        }

        // Update highlighting on input
        editor.addEventListener('input', updateHighlighting);
        editor.addEventListener('scroll', syncScroll);

        // Initial highlight
        updateHighlighting();

        function runCode() {
            const code = editor.value;
            status.textContent = 'Running...';
            output.textContent = 'Executing...';

            try {
                console.log('Running code:', code);

                // Add timeout to prevent infinite loops
                let result;
                const timeout = setTimeout(() => {
                    throw new Error('Execution timeout - possible infinite loop');
                }, 5000);

                result = Stellogen.run(code);
                clearTimeout(timeout);

                console.log('Result:', result);
                output.textContent = result || '(no output)';
                output.className = 'success';
                status.textContent = 'Success';
                setTimeout(() => status.textContent = '', 2000);
            } catch (e) {
                console.error('Error:', e);
                output.textContent = 'JavaScript error: ' + e.message + '\n\nCheck browser console (F12) for details.';
                output.className = 'error';
                status.textContent = 'Error';
            }
        }

        function clear() {
            editor.value = '';
            output.textContent = 'Click "Run" to execute your code...';
            output.className = '';
            updateHighlighting();
        }

        // Export function - download current code as .sg file
        function exportCode() {
            const code = editor.value;
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;

            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace(/:/g, '-');
            a.download = `stellogen-${timestamp}.sg`;

            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            status.textContent = 'Exported!';
            setTimeout(() => status.textContent = '', 2000);
        }

        // Import function - trigger file picker
        function importCode() {
            fileInput.click();
        }

        // Handle file selection
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                editor.value = event.target.result;
                updateHighlighting();
                status.textContent = `Imported: ${file.name}`;
                setTimeout(() => status.textContent = '', 2000);
            };
            reader.onerror = () => {
                status.textContent = 'Import failed!';
                setTimeout(() => status.textContent = '', 2000);
            };
            reader.readAsText(file);

            // Reset input so same file can be selected again
            e.target.value = '';
        });

        runBtn.addEventListener('click', runCode);
        clearBtn.addEventListener('click', clear);
        importBtn.addEventListener('click', importCode);
        exportBtn.addEventListener('click', exportCode);

        examplesSelect.addEventListener('change', (e) => {
            const example = examples[e.target.value];
            if (example) {
                editor.value = example;
                updateHighlighting();
                e.target.value = '';
            }
        });

        // Keyboard shortcuts
        editor.addEventListener('keydown', (e) => {
            // Ctrl+Enter or Cmd+Enter to run
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                runCode();
                return;
            }

            // Tab key inserts spaces instead of changing focus
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                editor.value = editor.value.substring(0, start) + '  ' + editor.value.substring(end);
                editor.selectionStart = editor.selectionEnd = start + 2;
                updateHighlighting();
            }
        });
    </script>
</body>
</html>
