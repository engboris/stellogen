(:= (initial Q) {
  [(-i [C|W]) (+m Q [e e] C W)]
  [(-i [])    (+m Q e e e)]
})

(:= (accept Q) [(-m qa L e R) accept])
(:= (reject Q) [(-m qr L C R) reject])

(:= (if Q1 then Q2) [(-m Q1 L e R) (+m Q2 L e R)])
(:= (skip right on Q , D) [(-m Q L D [C|R]) (+m Q [D|L] C R)])

(:= (if C1 on Q1 then Q2 , write C2 , right)
  [(-m Q1 L C1 [C|R]) (+m Q2 [C2|L] C R)])

(:= (if C1 on Q1 then Q2 , write C2 , left)
  [(-m Q1 [C|L] C1 R) (+m Q2 L C [C2|R])])

' Turing machine accepting words with as many 'a' as 'b'
(:= mt {
  #(initial q0)
  ' accept
  #(accept qa)
  #(if q0 then qa)
  ' reject
  #(reject qr)
  #(if q2 then qr)
  #(if q3 then qr)
  ' initial skip
  #(skip right on q0 , sep)
  'mark
  #(if a on q0 then q2 , write sep , right)
  #(if b on q0 then q3 , write sep , right)
  'skip
  #(skip right on q2 , a)
  #(skip right on q2 , sep)
  #(skip right on q3 , b)
  #(skip right on q3 , sep)
  'join
  #(if b on q2 then q1 , write sep , left)
  #(if a on q3 then q1 , write sep , left)
  'return
  #(if a on q1 then q1 , write a , left)
  #(if b on q1 then q1 , write b , left)
  #(if sep on q1 then q1 , write sep , left)
  #(if e on q1 then q0 , write e , right)
})

(:= (word W) (+i W))

(show (exec @#(word [a e]) #mt))
(show (exec @#(word [b e]) #mt))
(show (exec @#(word [a b b e]) #mt))

(show (exec @#(word [e]) #mt))
(show (exec @#(word [a b e]) #mt))
(show (exec @#(word [a a b b e]) #mt))
(show (exec @#(word [a b b a e]) #mt))
(show (exec @#(word [a b a b e]) #mt))
