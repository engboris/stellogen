'define ray
(:= a (-f X))

'define star
(:= b [(-f X)])

'define constellation
(:= c [
  @[+a] 'focus
  [-a b]])

'full focus
(:= f @[ [a] [b] [c] ])

'identifier
(:= x #a)

'union
(:= x (union #a #b))

'string literals
(:= s "hello world")

'cons
' [0 1 e] == %cons(0 (%cons 1 %nil))
(:= w (+w [0 1 0 1]))

'stack
' <s s 0> == (s (s 0))
(:= n (+nat <s s 0>))

'execution
(:= x [(+f X) X])
(:= y (-f a))
(:= ex (linexec (union @#x #y))) 'linear
(:= ex (exec (union @#x #y)))    'non-linear

'show constellation
(show #ex)
(show [ [a] [b] [c] ])
(show #s)

'complex identifiers
(:= (f a b) [(function a b)])
(show #(f a b))

'inequality constraints
(:= ineq [
  [(+f a)]
  [(+f b)]
  @[(-f X) (-f Y) (r X Y) | (!= X Y)]])
(show #ineq)
<show exec #ineq>

'interactive debugging of execution
'(trace #ineq)

'process
(:= c (process
  (+n0 0)                 'base constellation
  [(-n0 X) (+n1 (s X))]   'interacts with previous
  [(-n1 X) (+n2 (s X))])) 'interacts with previous
(show #c)

'constellation with fields
(:= g [
  [+test1 [(+f a) ok]]
  [+test2 [(+f b) ok]]])
(show #g)

'field access and evaluation
<show eval exec (union #g @[-test1])>
<show eval exec (union #g @[-test2])>

'nested fields
(:= g1 [
  [+test1 [
    [+test2 [(+f c) ok]]]]])
(:= g2 <eval exec (union #g1 @[-test1])>)
<show eval exec (union #g2 @[-test2])>

'extend rays with a head function symbol
'<show exec [[(+f X)] [(f X)]][=>+a]>
'<show exec [[(+f X)] [(f X)]][=>a]>

'remove head function symbol from a ray
'<show-exec [[(+f X)] [(f X)]][+f=>]>

'substitutions
'<show exec (+f X)[X=>(+a X)]>
'<show exec (+f X)[+f=>+g]>
'<show exec (union #1 #2)
'  [#1=>[(+f X) X)]]
'  [#2=>(-f a)]>

'define type
(spec nat [
  [(-nat 0) ok]
  [(-nat (s N)) (+nat N)]])

'expect
(:= x 0)
(== x 0)
'(== x 1)

'type checking
(:= 2 <+nat s s 0>)
(:= test @(exec (union @#2 #nat)))
(== test ok)

'import file
'(use "examples/automata.sg")

'declaration definition
(new-declaration (:: tested test)
  (:= test @(exec (union @#tested #test)))
  (== test ok))
(:: 2 nat)
