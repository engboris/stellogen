'static definition of constellation
(:= x [
  [+a]
  [-a b]])

(:= y #x)

(:= z (-f X))

'string literals
'(:= w ["hello world"])

'cons
(:= w [(+w [0 1 0 1 e])])

'print result of execution
(:= x [(+f X) X])
(:= y (-f a))
<show exec (union @#x #y)>

'complex identifiers
(:= (f a b) [(function a b)])
(show #(f a b))

'show (literal) contellations
(show [ [a] [b] [c] ])

'full focus
(show @[ [a] [b] [c] ])

'inequality constraints
(:= ineq [
  [(+f a)]
  [(+f b)]
  @[(-f X) (-f Y) (r X Y) | (!= X Y)]])
(show #ineq)
<show exec #ineq>

'interactive debugging of execution
'(trace #ineq)

'dynamic definition of constellation
(:= c (process
  (+n0 0)                 'base constellation
  [(-n0 X) (+n1 (s X))]   'interacts with previous
  [(-n1 X) (+n2 (s X))])) 'interacts with previous
(show #c)

'constellation with fields
(:= g [
  [+test1 [(+f a) ok]]
  [+test2 [(+f b) ok]]])
(show #g)

'field access and evaluation
<show eval exec (union #g @[-test1])>
<show eval exec (union #g @[-test2])>

'nested fields
(:= g1 [
  [+test1 [
    [+test2 [(+f c) ok]]]]])
(:= g2 <eval exec (union #g1 @[-test1])>)
<show eval exec (union #g2 @[-test2])>

'extend rays with a head function symbol
'<show exec [[(+f X)] [(f X)]][=>+a]>
'<show exec [[(+f X)] [(f X)]][=>a]>

'remove head function symbol from a ray
'<show-exec [[(+f X)] [(f X)]][+f=>]>

'substitutions
'<show exec (+f X)[X=>(+a X)]>
'<show exec (+f X)[+f=>+g]>
'<show exec (union #1 #2)
'  [#1=>[(+f X) X)]]
'  [#2=>(-f a)]>

'checkers & typechecking
(:= checker [
  [+interaction (union @#tested #test)]
  [+expect ok]])

(spec nat [
  [(-nat 0) ok]
  [(-nat (s N)) (+nat N)]])

'manual type checking
(:= 0 (+nat 0))
(:= test @(exec (union @#0 #nat)))
(== test ok)

(:= 2 <+nat s s 0>)
(:= test @(exec (union @#0 #nat)))
(== test ok)

'import file
'(use examples automata)
